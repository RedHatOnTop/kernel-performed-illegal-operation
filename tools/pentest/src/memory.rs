//! Memory Attack Tests
//!
//! Tests for memory safety vulnerabilities:
//! - Buffer overflow
//! - Heap overflow
//! - Use-after-free
//! - Double free
//! - Format string
//! - Integer overflow

use crate::TestResult;

/// PT001: Buffer overflow test
/// 
/// Tests stack buffer overflow protection.
/// In Rust, this is handled by bounds checking at compile and runtime.
pub fn test_buffer_overflow() -> TestResult {
    // Rust prevents buffer overflows through bounds checking
    // This test verifies that out-of-bounds access panics
    
    let buffer = [0u8; 16];
    
    // Safe access - should work
    let _val = buffer.get(0);
    
    // Out-of-bounds access - should return None (not crash/overflow)
    let oob = buffer.get(100);
    
    if oob.is_none() {
        TestResult::pass(
            "PT001",
            "Buffer overflow",
            "Bounds checked"
        ).with_notes("Rust slice::get returns None for out-of-bounds")
    } else {
        TestResult::fail(
            "PT001",
            "Buffer overflow",
            "Bounds checked",
            "Access succeeded"
        )
    }
}

/// PT002: Heap overflow test
///
/// Tests heap allocation overflow protection.
pub fn test_heap_overflow() -> TestResult {
    // Rust Vec prevents heap overflow through capacity tracking
    let mut vec = Vec::with_capacity(10);
    for i in 0..10 {
        vec.push(i);
    }
    
    // Vec automatically reallocates if needed
    vec.push(10);  // This triggers reallocation, not overflow
    
    // Check that we can't access beyond length
    let oob = vec.get(100);
    
    if oob.is_none() && vec.len() == 11 {
        TestResult::pass(
            "PT002",
            "Heap overflow",
            "Reallocation instead of overflow"
        ).with_notes("Vec safely reallocates on growth")
    } else {
        TestResult::fail(
            "PT002",
            "Heap overflow",
            "Safe reallocation",
            "Unexpected behavior"
        )
    }
}

/// PT003: Use-after-free test
///
/// Tests use-after-free protection.
/// Rust's ownership system prevents this at compile time.
pub fn test_use_after_free() -> TestResult {
    // This test demonstrates that Rust prevents use-after-free
    // The following would not compile:
    // let ptr = Box::new(42);
    // drop(ptr);
    // let val = *ptr;  // Compile error: use of moved value
    
    // Instead, we verify Option-based patterns work correctly
    let mut maybe_value: Option<Box<i32>> = Some(Box::new(42));
    
    // Take ownership (simulates free)
    let taken = maybe_value.take();
    
    // Original is now None
    let is_none = maybe_value.is_none();
    let was_42 = taken.map(|b| *b) == Some(42);
    
    if is_none && was_42 {
        TestResult::pass(
            "PT003",
            "Use-after-free",
            "Prevented by ownership"
        ).with_notes("Rust ownership prevents use-after-free at compile time")
    } else {
        TestResult::fail(
            "PT003",
            "Use-after-free",
            "Compile-time prevention",
            "Unexpected runtime behavior"
        )
    }
}

/// PT004: Double free test
///
/// Tests double free protection.
/// Rust's ownership system prevents this at compile time.
pub fn test_double_free() -> TestResult {
    // This would not compile in Rust:
    // let b = Box::new(42);
    // drop(b);
    // drop(b);  // Compile error: use of moved value
    
    // Verify that Option::take properly handles this
    let mut maybe_box: Option<Box<i32>> = Some(Box::new(42));
    
    // First "free" via take
    let first = maybe_box.take();
    
    // Second "free" via take - returns None
    let second = maybe_box.take();
    
    if first.is_some() && second.is_none() {
        TestResult::pass(
            "PT004",
            "Double free",
            "Prevented by ownership"
        ).with_notes("Rust ownership prevents double free at compile time")
    } else {
        TestResult::fail(
            "PT004",
            "Double free",
            "Single free only",
            "Unexpected behavior"
        )
    }
}

/// PT005: Format string test
///
/// Tests format string vulnerability protection.
/// Rust's format! macro is type-safe and doesn't interpret format specifiers from data.
pub fn test_format_string() -> TestResult {
    // In C: printf(user_input) would be vulnerable
    // In Rust: format!("{}", user_input) treats user_input as data, not format
    
    let malicious_input = "%s%s%s%s%s%n%n%n%n%n";
    
    // This is safe - the string is treated as literal data
    let result = format!("{}", malicious_input);
    
    // The output should be exactly the input, not interpreted as format specifiers
    if result == malicious_input {
        TestResult::pass(
            "PT005",
            "Format string",
            "Data not interpreted as format"
        ).with_notes("Rust format! is compile-time type-safe")
    } else {
        TestResult::fail(
            "PT005",
            "Format string",
            "Literal output",
            &result
        )
    }
}

/// PT006: Integer overflow test
///
/// Tests integer overflow handling.
/// In debug mode, Rust panics on overflow. In release, we use checked operations.
pub fn test_integer_overflow() -> TestResult {
    // Use checked operations that handle overflow
    let max = u32::MAX;
    
    // checked_add returns None on overflow
    let overflow_result = max.checked_add(1);
    
    // saturating_add clamps to max value
    let saturate_result = max.saturating_add(1);
    
    // wrapping_add wraps around (explicit)
    let wrap_result = max.wrapping_add(1);
    
    let overflow_handled = overflow_result.is_none();
    let saturate_correct = saturate_result == u32::MAX;
    let wrap_correct = wrap_result == 0;
    
    if overflow_handled && saturate_correct && wrap_correct {
        TestResult::pass(
            "PT006",
            "Integer overflow",
            "Handled by checked/saturating/wrapping ops"
        ).with_notes("Use checked_*, saturating_*, or wrapping_* operations")
    } else {
        TestResult::fail(
            "PT006",
            "Integer overflow",
            "Explicit overflow handling",
            "Unexpected behavior"
        )
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_all_memory_tests_pass() {
        assert!(test_buffer_overflow().passed);
        assert!(test_heap_overflow().passed);
        assert!(test_use_after_free().passed);
        assert!(test_double_free().passed);
        assert!(test_format_string().passed);
        assert!(test_integer_overflow().passed);
    }
}
