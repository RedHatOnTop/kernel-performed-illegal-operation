//! KPIO Security Penetration Testing Framework
//!
//! Provides automated security testing for:
//! - Memory attacks (buffer overflow, use-after-free, etc.)
//! - Syscall attacks (invalid arguments, race conditions)
//! - Browser attacks (XSS, CSRF, CSP bypass)
//! - Privilege escalation attempts

use std::collections::HashMap;

mod memory;
mod syscall;
mod browser;
mod privilege;

/// Test result
#[derive(Debug, Clone)]
pub struct TestResult {
    pub test_id: String,
    pub name: String,
    pub passed: bool,
    pub expected: String,
    pub actual: String,
    pub notes: Option<String>,
}

impl TestResult {
    pub fn pass(test_id: &str, name: &str, expected: &str) -> Self {
        Self {
            test_id: test_id.to_string(),
            name: name.to_string(),
            passed: true,
            expected: expected.to_string(),
            actual: expected.to_string(),
            notes: None,
        }
    }

    pub fn fail(test_id: &str, name: &str, expected: &str, actual: &str) -> Self {
        Self {
            test_id: test_id.to_string(),
            name: name.to_string(),
            passed: false,
            expected: expected.to_string(),
            actual: actual.to_string(),
            notes: None,
        }
    }

    pub fn with_notes(mut self, notes: &str) -> Self {
        self.notes = Some(notes.to_string());
        self
    }
}

/// Test category
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum TestCategory {
    Memory,
    Syscall,
    Browser,
    Privilege,
}

impl std::fmt::Display for TestCategory {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TestCategory::Memory => write!(f, "Memory"),
            TestCategory::Syscall => write!(f, "Syscall"),
            TestCategory::Browser => write!(f, "Browser"),
            TestCategory::Privilege => write!(f, "Privilege"),
        }
    }
}

/// Penetration test suite
pub struct PenTestSuite {
    results: HashMap<TestCategory, Vec<TestResult>>,
    verbose: bool,
}

impl PenTestSuite {
    pub fn new(verbose: bool) -> Self {
        Self {
            results: HashMap::new(),
            verbose,
        }
    }

    pub fn add_result(&mut self, category: TestCategory, result: TestResult) {
        if self.verbose {
            let status = if result.passed { "PASS" } else { "FAIL" };
            println!("[{}] {} - {}", status, result.test_id, result.name);
        }
        
        self.results.entry(category).or_insert_with(Vec::new).push(result);
    }

    pub fn run_all(&mut self) {
        println!("=== KPIO Security Penetration Tests ===\n");

        // Memory attacks
        println!("[*] Testing memory protections...");
        self.run_memory_tests();

        // Syscall attacks
        println!("\n[*] Testing syscall protections...");
        self.run_syscall_tests();

        // Browser attacks
        println!("\n[*] Testing browser protections...");
        self.run_browser_tests();

        // Privilege attacks
        println!("\n[*] Testing privilege boundaries...");
        self.run_privilege_tests();

        println!("\n=== Results ===");
        self.print_summary();
    }

    fn run_memory_tests(&mut self) {
        // PT001: Buffer overflow
        let result = memory::test_buffer_overflow();
        self.add_result(TestCategory::Memory, result);

        // PT002: Heap overflow
        let result = memory::test_heap_overflow();
        self.add_result(TestCategory::Memory, result);

        // PT003: Use-after-free
        let result = memory::test_use_after_free();
        self.add_result(TestCategory::Memory, result);

        // PT004: Double free
        let result = memory::test_double_free();
        self.add_result(TestCategory::Memory, result);

        // PT005: Format string
        let result = memory::test_format_string();
        self.add_result(TestCategory::Memory, result);

        // PT006: Integer overflow
        let result = memory::test_integer_overflow();
        self.add_result(TestCategory::Memory, result);
    }

    fn run_syscall_tests(&mut self) {
        // PT011: Invalid syscall
        let result = syscall::test_invalid_syscall();
        self.add_result(TestCategory::Syscall, result);

        // PT012: Kernel pointer
        let result = syscall::test_kernel_pointer();
        self.add_result(TestCategory::Syscall, result);

        // PT013: Huge size
        let result = syscall::test_huge_size();
        self.add_result(TestCategory::Syscall, result);

        // PT014: Race condition (TOCTOU)
        let result = syscall::test_race_condition();
        self.add_result(TestCategory::Syscall, result);

        // PT015: FD abuse
        let result = syscall::test_fd_abuse();
        self.add_result(TestCategory::Syscall, result);
    }

    fn run_browser_tests(&mut self) {
        // PT021: XSS reflected
        let result = browser::test_xss_reflected();
        self.add_result(TestCategory::Browser, result);

        // PT022: XSS stored
        let result = browser::test_xss_stored();
        self.add_result(TestCategory::Browser, result);

        // PT023: XSS DOM
        let result = browser::test_xss_dom();
        self.add_result(TestCategory::Browser, result);

        // PT024: CSRF
        let result = browser::test_csrf();
        self.add_result(TestCategory::Browser, result);

        // PT025: Open redirect
        let result = browser::test_open_redirect();
        self.add_result(TestCategory::Browser, result);

        // PT026: Path traversal
        let result = browser::test_path_traversal();
        self.add_result(TestCategory::Browser, result);

        // PT027: CSP bypass
        let result = browser::test_csp_bypass();
        self.add_result(TestCategory::Browser, result);

        // PT028: Clickjacking
        let result = browser::test_clickjacking();
        self.add_result(TestCategory::Browser, result);
    }

    fn run_privilege_tests(&mut self) {
        // PT031: Capability escalation
        let result = privilege::test_cap_escalation();
        self.add_result(TestCategory::Privilege, result);

        // PT032: Sandbox escape
        let result = privilege::test_sandbox_escape();
        self.add_result(TestCategory::Privilege, result);

        // PT033: IPC exploit
        let result = privilege::test_ipc_exploit();
        self.add_result(TestCategory::Privilege, result);

        // PT034: Resource abuse (fork bomb)
        let result = privilege::test_resource_abuse();
        self.add_result(TestCategory::Privilege, result);
    }

    fn print_summary(&self) {
        let mut total_passed = 0;
        let mut total_failed = 0;

        for (category, results) in &self.results {
            let passed = results.iter().filter(|r| r.passed).count();
            let failed = results.iter().filter(|r| !r.passed).count();
            
            total_passed += passed;
            total_failed += failed;

            println!("\n{} Tests:", category);
            println!("  Passed: {} / {}", passed, results.len());
            
            if failed > 0 {
                println!("  Failed:");
                for result in results.iter().filter(|r| !r.passed) {
                    println!("    - {} ({})", result.name, result.test_id);
                    println!("      Expected: {}", result.expected);
                    println!("      Actual:   {}", result.actual);
                }
            }
        }

        println!("\n─────────────────────────────────────────");
        println!("Total: {} passed, {} failed", total_passed, total_failed);
        
        if total_failed == 0 {
            println!("✓ All penetration tests passed!");
        } else {
            println!("✗ {} test(s) need attention", total_failed);
        }
    }

    pub fn generate_report(&self) -> String {
        let mut report = String::new();
        
        report.push_str("KPIO OS Security Penetration Test Report\n");
        report.push_str("========================================\n\n");

        let mut total_passed = 0;
        let mut total_failed = 0;
        let mut critical_issues = Vec::new();

        for (category, results) in &self.results {
            report.push_str(&format!("## {} Tests\n\n", category));
            report.push_str("| Test ID | Name | Status | Expected | Actual |\n");
            report.push_str("|---------|------|--------|----------|--------|\n");

            for result in results {
                let status = if result.passed { "✓" } else { "✗" };
                report.push_str(&format!(
                    "| {} | {} | {} | {} | {} |\n",
                    result.test_id, result.name, status, result.expected, result.actual
                ));

                if result.passed {
                    total_passed += 1;
                } else {
                    total_failed += 1;
                    critical_issues.push(format!("{}: {}", result.test_id, result.name));
                }
            }
            report.push('\n');
        }

        report.push_str("\n## Summary\n\n");
        report.push_str(&format!("- Total Tests: {}\n", total_passed + total_failed));
        report.push_str(&format!("- Passed: {}\n", total_passed));
        report.push_str(&format!("- Failed: {}\n", total_failed));

        if !critical_issues.is_empty() {
            report.push_str("\n## Critical Issues\n\n");
            for issue in &critical_issues {
                report.push_str(&format!("- {}\n", issue));
            }
        }

        report
    }
}

fn main() {
    let args: Vec<String> = std::env::args().collect();
    let verbose = args.contains(&"--verbose".to_string()) || args.contains(&"-v".to_string());
    let report = args.contains(&"--report".to_string());

    let mut suite = PenTestSuite::new(verbose);
    suite.run_all();

    if report {
        let report_content = suite.generate_report();
        std::fs::write("pentest_report.md", report_content).expect("Failed to write report");
        println!("\nReport saved to pentest_report.md");
    }
}
